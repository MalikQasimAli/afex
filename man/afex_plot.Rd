% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/afex_plot.R
\name{afex_plot}
\alias{afex_plot}
\alias{afex_plot.afex_aov}
\alias{interaction_plot}
\alias{oneway_plot}
\title{m-way Interaction Plot with Error Bars and Raw Data}
\usage{
afex_plot(object, ...)

\method{afex_plot}{afex_aov}(object, x, trace, panels, mapping,
  error = "model", error_exp = 1, error_arg = list(width = 0),
  data_plot = TRUE, data_geom, data_alpha = 0.5,
  data_arg = list(color = "darkgrey"), point_arg = list(),
  line_arg = list(), emmeans_arg = list(), dodge = 0.2,
  return = "plot", new_levels = list(), ...)

interaction_plot(means, data, mapping = c("shape", "lineytpe"),
  error_plot = TRUE, error_exp = 1, error_arg = list(width = 0),
  data_plot = TRUE, data_geom = ggplot2::geom_point,
  data_alpha = 0.5, data_arg = list(color = "darkgrey"),
  point_arg = list(), line_arg = list(), dodge = 0.2)

oneway_plot(means, data, mapping = "", error_plot = TRUE,
  error_exp = 1, error_arg = list(width = 0), data_plot = TRUE,
  data_geom = ggbeeswarm::geom_beeswarm, data_alpha = 0.5,
  data_arg = list(color = "darkgrey"), point_arg = list(),
  line_arg = list())
}
\arguments{
\item{object}{object of class \code{afex_aov} as returned from 
\code{\link{aov_car}} and related functions.}

\item{...}{currently ignored.}

\item{x}{A \code{character} vector or one-sided \code{formula} specifying the
factor names of the predictors displayed on the x-axis.}

\item{trace}{A \code{character} vector or one-sided \code{formula} specifying
the factor names of the predictors connected by the same line. Argument 
\code{mapping} specifies further mappings for these factors. Optional.}

\item{panels}{A \code{character} vector or one-sided \code{formula} 
specifying the factor names of the predictors shown in different panels. 
Optional.}

\item{mapping}{A \code{character} vector specifying which aesthetic mappings 
should be applied to either the \code{trace} factors (if \code{trace} is 
specified) or the \code{x} factors. Useful options are any combination of 
\code{"shape"}, \code{"color"}, and \code{"linetype"} or also \code{"fill"}
(see examples). The default (i.e., missing) uses \code{c("shape",
"lineytpe")} if \code{trace} is specified, otherwise \code{""} (i.e., no
additional aesthetic).}

\item{error}{A scalar \code{character} specifying which type of standard 
error should be plotted. Default is \code{"model"}, which plots model-based
standard errors. Further options are: \code{"none"} (or \code{NULL}),
\code{"mean-SE"}, \code{"within-SE"} (or \code{"CMO"}), and 
\code{"between-SE"}. See details.}

\item{error_exp}{Numeric expansion factor for standard error. Default is 
\code{1} which plots \code{+/- 1} standard error. \code{qnorm(0.975)} or 
\code{1.96} plots 95\% confidence intervals based on the normal
distribution.}

\item{error_arg}{A \code{list} of further arguments passed to 
\code{\link[ggplot2]{geom_errorbar}}, which draws the errorsbars. Default 
is \code{list(width = 0)} which suppresses the vertical bars at the end of 
the error bar.}

\item{data_plot}{\code{logical}. Should raw data be plotted in the 
background? Default is \code{TRUE}.}

\item{data_geom}{Geom \code{function} used for plotting data in background. 
The default (missing) uses \code{\link[ggplot2]{geom_point}} if \code{trace}
is specified, otherwise \code{\link[ggbeeswarm]{geom_beeswarm}}. See
examples.}

\item{data_alpha}{\code{alpha} value passed to \code{data_geom}.}

\item{data_arg}{A \code{list} of further arguments passed to 
\code{data_geom}. Default is \code{list(color = "darkgrey")}.}

\item{point_arg, line_arg}{A \code{list} of further arguments passed to 
\code{\link[ggplot2]{geom_point}} or \code{\link[ggplot2]{geom_line}} which
draw the points and lines in the foreground. Default is \code{list()}.
\code{line_arg} is only used if \code{trace} is specified.}

\item{emmeans_arg}{A \code{list} of further arguments passed to 
\code{\link[emmeans]{emmeans}}. Of particular importance for ANOVAs is 
\code{model}, see \code{\link{afex_aov-methods}}.}

\item{dodge}{Numerical amount of dodging of factor-levels on x-axis. Default 
is \code{0.2}.}

\item{return}{A scalar \code{character} specifying what should be returned. 
The default \code{"plot"} returns the \pkg{ggplot2} plot. The other option 
\code{"data"} returns a list with two \code{data.frame}s containing the 
data used for plotting: \code{means} contains the means and standard errors
for the foreground, \code{data} contains the raw data in the background.}

\item{new_levels}{A \code{list} of new factor levels that should be used in 
the plot. The name of each list entry needs to correspond to one of the 
factors in the plot.}

\item{means, data}{\code{data.frame}s used for plotting. Need to contain 
columns \code{y}, \code{x}, \code{trace}, and \code{error} (only in 
\code{means}).}

\item{error_plot}{\code{logical}. Should error bars be plotted? Only used in
plotting functions. Use \code{error = "none"} otherwise.}
}
\value{
Returns a \pkg{ggplot2} plot (i.e., object of class \code{c("gg",
  "ggplot")}) unless \code{return = "data"}.
}
\description{
Plots results from factorial experiments. Estimated marginal 
  means and error bars are plotted in the foreground, raw data is plotted in 
  the background. Error bars can be based on different standard errors (e.g.,
  model-based, within-subjects, between-subjects). Functions described here 
  are extremely flexible and allow customization of almost any characteristic
  of the plot.
  
  \code{afex_plot} is the user friendly function that does data preparation
  and plotting. It also allows to only return the prepared data (\code{return
  = "data"}).
  
  \code{interaction_plot} does the plotting when a \code{trace} factor is
  present. \code{oneway_plot} does the plotting when a \code{trace} factor is
  absent.
}
\details{
\code{afex_plot} obtains the estimated marginal means via
  \code{\link[emmeans]{emmeans}} and aggregates the raw data to the same
  level. It then calculates the desired standard error (see below) and passes
  the prepared data to one of the two plotting functions:
  \code{interaction_plot} when \code{trace} is specified and
  \code{oneway_plot} otherwise.

  \subsection{Error Bars}{Error bars provide a grahical representation of the
  variability of the estimated means and should be routinely added to results
  figures. However, there exist several possibilities which particular
  measure of variability to use. Because of this, any figure depicting error
  bars should be accompanied by a note detailing which measure the error bars
  shows. The present functions allow plotting of different types of standard
  errors (if \code{error_exp = 1}) or confidence intervals (e.g., 95\%
  confidence intervals based on the normal distribution if \code{error_exp =
  1.96}).
  
  A further complication is that readers routinely misinterpret confidence 
  intervals. The most common error is to assume that non-overlapping error 
  bars indicate a significant difference (e.g., Belia et al., 2005). This is 
  rarely the case (see e.g., Cumming & Finch, 2005; Knol et al., 2011; 
  Schenker & Gentleman, 2005). For example, in a fully between-subject design
  in which the error bars depict 95% confidence intervals and groups are of 
  approximately equal size and have equal variance, even error bars that 
  overlap by as much as 50\% still correspond to \emph{p} < .05. Error bars 
  that are just touching roughly correspond to \emph{p} = .01.
  
  In the case of repeated-measures designs the usual standard errors or 
  confidence intervals (i.e., model-based standard errors or standard errors 
  of the mean) cannot be used to gauge significant differences as this 
  requires knowledge about the correlation between measures. One popular 
  alternative in the psychological literature are intervals based on 
  within-subject standard errors/confidence intervals (e.g., Cousineau & 
  O'Brien, 2014). These attempt to control for the correlation across 
  individuals and thereby allow judging differences between repeated-measures
  condition. As a downside, when using within-subject intervals no
  comparisons across between-subject conditions or with respect to a
  fixed-value are possible anymore.
  
  In the case of a mixed-design, no single type of error bar is possible that
  allows comparison across all conditions. Therefore, special care is
  necessary in such cases.
  
  The following "rules of eye" (Cumming and Finch, 2005) hold, when permitted
  by design (i.e., within-subject bars for within-subject comparisons; other 
  variants for between-subject comparisons), and groups are approximately 
  equal in size and variance:
  \itemize{
    \item  \emph{p} < .05 when the gap between standard error (SE) bars is at
    least about the size of the average SE, that is, when the proportion gap
    is about 1 or greater.
    \item \emph{p} < .01 when the proportion gap between SE bars is about 2
    or more.
    \item  \emph{p} < .05 when the overlap of the 95\% confidence intervals
    (CIs) is no more than about half the average margin of error, that is,
    when proportion overlap is about .50 or less.
    \item \emph{p} < .01 when the two CIs do not overlap, that is, when
    proportion overlap is about 0 or there is a positive gap.
  }   
  }
  \subsection{Implemented Standard Errors}{
  The following lists the implemented approaches to calculate standard
  errors (SEs). These can be used to construe confidence intervals via the
  \code{error_exp} argument.
  \describe{
    \item{\code{"model"}}{Uses the model-based SEs. For ANOVAs, the variant
    based on the \code{lm} or \code{mlm} model (i.e., \code{emmeans_arg =
    list(model = "multivariate")}) seems generally preferrable.}
    \item{\code{"mean-SE"}}{Calculates the standard error of the mean for
    each cell ignoring any repeated-measures factors.}
    \item{\code{"within-SE"} or \code{"CMO"}}{Calculates within-subject SEs using the
    Cosineau-Morey-O'Brien (Cousineau & O'Brien, 2014) method. This method
    is based on a double normalization of the data. SEs are then calculated
    independently for each cell (i.e., if the desired output contains
    between-subject factors, SEs are calculated for each cell including the
    between-subject factors).}
    \item{\code{"between-SE"}}{First aggregates the data per participant and
    then calculates the SEs for each between-subject condition. Results in
    one SE for all conditions in purely within-subjects designs.}
    \item{\code{"none"} or \code{NULL}}{Suppresses calculation of SEs and
    plots no error bars.}
  }
  }
}
\examples{

##################################################################
##                2-factor Within-Subject Design                ##
##################################################################

data(md_12.1)
aw <- aov_ez("id", "rt", md_12.1, within = c("angle", "noise"))

##---------------------------------------------------------------
##                    Basic Interaction Plots                   -
##---------------------------------------------------------------

afex_plot(aw, x = "angle", trace = "noise") 
# or: afex_plot(aw, x = ~angle, trace = ~noise)

afex_plot(aw, x = "noise", trace = "angle")

### For within-subject designs, using within-subject CIs is probably better:
(p1 <- afex_plot(aw, x = "noise", trace = "angle", 
                 error = "within-SE", error_exp = 1.96))

## use different themes for nicer graphs:
p1 + ggplot2::theme_classic()
p1 + ggplot2::theme_light()
p1 + ggplot2::theme_minimal()
\dontrun{
p1 + jtools::theme_apa()
p1 + ggpubr::theme_pubr()

### set theme globally for R session:
ggplot2::theme_set(ggplot2::theme_light())
}

### There are several ways to deal with overlapping points in the background besides alpha

# 1. using the default data geom and ggplot2::position_jitterdodge
afex_plot(aw, x = "noise", trace = "angle", dodge = 0.2,
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 2, 
                dodge.width = 0.2  ## needs to be same as dodge
                ),
            color = "darkgrey"))

\dontrun{
# 2. using ggbeeswarm::geom_beeswarm
afex_plot(aw, x = "noise", trace = "angle", dodge = 0.5,
          data_geom = ggbeeswarm::geom_beeswarm,
          data_arg = list(
            dodge.width = 0.5,  ## needs to be same as dodge
            cex = 0.8,
            color = "darkgrey"
          ))
}

# 3. do not display points, but use a violinplot: ggplot2::geom_violin
afex_plot(aw, x = "noise", trace = "angle", dodge = 0.5,
          data_geom = ggplot2::geom_violin, 
          data_arg = list(width = 0.5))

# 4. violinplots with color: ggplot2::geom_violin
afex_plot(aw, x = "noise", trace = "angle", dodge = 0.5, 
          mapping = c("linetype", "shape", "fill"),
          data_geom = ggplot2::geom_violin, 
          data_arg = list(width = 0.5))

# 5. do not display points, but use a boxplot: ggplot2::geom_violin
afex_plot(aw, x = "noise", trace = "angle", dodge = 0.5,
          data_geom = ggplot2::geom_boxplot, 
          data_arg = list(width = 0.3))
          
\dontrun{
# 6. combine points with boxplot: ggpol::geom_boxjitter
## currently requires attaching ggpol explicitly:
library("ggpol")
afex_plot(aw, x = "noise", trace = "angle", dodge = 0.5,
          data_geom = ggpol::geom_boxjitter, 
          data_arg = list(width = 0.3))
## hides error bars!

# 7. nicer variant of ggpol::geom_boxjitter
afex_plot(aw, x = "noise", trace = "angle", dodge = 0.5,
          mapping = c("shape", "fill"),
          data_geom = ggpol::geom_boxjitter, 
          data_arg = list(
            width = 0.3, 
            jitter.width = 0,
            jitter.height = 10,
            outlier.intersect = TRUE),
          point_arg = list(size = 2.5), 
          error_arg = list(size = 1.5, width = 0))


# 8. nicer variant of ggpol::geom_boxjitter without lines
afex_plot(aw, x = "noise", trace = "angle", dodge = 0.7,
          mapping = c("shape", "fill"),
          data_geom = ggpol::geom_boxjitter, 
          data_arg = list(
            width = 0.5, 
            jitter.width = 0,
            jitter.height = 10,
            outlier.intersect = TRUE),
          point_arg = list(size = 2.5), 
          line_arg = list(linetype = 0),
          error_arg = list(size = 1.5, width = 0))
}


##---------------------------------------------------------------
##                      Basic One-Way Plots                     -
##---------------------------------------------------------------

afex_plot(aw, x = "angle") ## default

## with color we need larger points
afex_plot(aw, x = "angle", mapping = "color", 
          point_arg = list(size = 2.5), 
          error_arg = list(size = 1.5, width = 0.05)) 

\dontrun{
library("ggpol") ## currently required for combination of boxplot and points
afex_plot(aw, x = "angle", data_geom = ggpol::geom_boxjitter)

## nicer with within-subject CIs:
afex_plot(aw, x = "angle", data_geom = ggpol::geom_boxjitter, 
          mapping = "fill", data_alpha = 0.7, 
          data_arg = list(
            width = 0.6, 
            jitter.width = 0.07,
            jitter.height = 10,
            outlier.intersect = TRUE
          ),
          point_arg = list(size = 2.5), 
          error_arg = list(size = 1.5, width = 0.05),
          error = "within-SE", error_exp = 1.96)
}


##---------------------------------------------------------------
##                      Other Basic Options                     -
##---------------------------------------------------------------

## relabel factor levels via new_levels
afex_plot(aw, x = "noise", trace = "angle", 
          new_levels = list(angle = c("0", "4", "8"),
                            noise = c("Absent", "Present")))

#################################################################
##                    4-factor Mixed Design                    ##
#################################################################

data(obk.long, package = "afex")
a1 <- aov_car(value ~ treatment * gender + Error(id/(phase*hour)), 
              data = obk.long, observed = "gender")

## too difficult to see anything
afex_plot(a1, ~phase*hour, ~treatment) +
  ggplot2::theme_light()

## better
afex_plot(a1, ~hour, ~treatment, ~phase) +
  ggplot2::theme_light()

## even better and different model-based standard errors
afex_plot(a1, ~hour, ~treatment, ~phase, 
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ),
            color = "darkgrey"),
          emmeans_arg = list(model = "multivariate")) +
  ggplot2::theme_light()

# with color instead of linetype to separate trace factor
afex_plot(a1, ~hour, ~treatment, ~phase, 
          mapping = c("shape", "color"),
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                )),
          emmeans_arg = list(model = "multivariate")) +
  ggplot2::theme_light()

# only color to separate trace factor
afex_plot(a1, ~hour, ~treatment, ~phase, 
          mapping = "color",
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                )),
          emmeans_arg = list(model = "multivariate")) +
  ggplot2::theme_light()


## plot involving all 4 factors:
afex_plot(a1, ~hour, ~treatment, ~gender+phase, 
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ),
            color = "darkgrey"),
          emmeans_arg = list(model = "multivariate")) +
  ggplot2::theme_light()


##---------------------------------------------------------------
##              Different Standard Errors Available             -
##---------------------------------------------------------------

## purely within-design
cbind(
  afex_plot(a1, ~phase, ~hour, 
            error = "model", return = "data")$means[,c("phase", "hour", "y", "SE")],
  multivariate = afex_plot(a1, ~phase, ~hour, 
                           emmeans_arg = list(model = "multivariate"),
                           error = "model", return = "data")$means$error,
  mean = afex_plot(a1, ~phase, ~hour, 
                    error = "mean-SE", return = "data")$means$error,
  within = afex_plot(a1, ~phase, ~hour, 
                     error = "within-SE", return = "data")$means$error,
  between = afex_plot(a1, ~phase, ~hour, 
                      error = "between-SE", return = "data")$means$error)
## mixed design
cbind(
  afex_plot(a1, ~phase, ~treatment, 
            error = "model", return = "data")$means[,c("phase", "treatment", "y", "SE")],
  multivariate = afex_plot(a1, ~phase, ~treatment, 
                           emmeans_arg = list(model = "multivariate"),
                           error = "model", return = "data")$means$error,
  mean = afex_plot(a1, ~phase, ~treatment, 
                    error = "mean-SE", return = "data")$means$error,
  within = afex_plot(a1, ~phase, ~treatment, 
                     error = "within-SE", return = "data")$means$error,
  between = afex_plot(a1, ~phase, ~treatment, 
                      error = "between-SE", return = "data")$means$error)
}
\references{
Belia, S., Fidler, F., Williams, J., & Cumming, G. (2005).
  Researchers Misunderstand Confidence Intervals and Standard Error Bars.
  \emph{Psychological Methods}, 10(4), 389-396.
  https://doi.org/10.1037/1082-989X.10.4.389
  
  Cousineau, D., & O'Brien, F. (2014). Error bars in within-subject designs:
  a comment on Baguley (2012). \emph{Behavior Research Methods}, 46(4),
  1149-1151. https://doi.org/10.3758/s13428-013-0441-z
  
  Cumming, G., & Finch, S. (2005). Inference by Eye: Confidence Intervals and
  How to Read Pictures of Data. \emph{American Psychologist}, 60(2), 170-180.
  https://doi.org/10.1037/0003-066X.60.2.170
  
  Knol, M. J., Pestman, W. R., & Grobbee, D. E. (2011). The (mis)use of
  overlap of confidence intervals to assess effect modification.
  \emph{European Journal of Epidemiology}, 26(4), 253-254.
  https://doi.org/10.1007/s10654-011-9563-8
  
  Schenker, N., & Gentleman, J. F. (2001). On Judging the Significance of
  Differences by Examining the Overlap Between Confidence Intervals.
  \emph{The American Statistician}, 55(3), 182-186.
  https://doi.org/10.1198/000313001317097960
}
